<node>
  <type_nodetype>4</type_nodetype>
  <delegated>1</delegated>
  <node_id>1251282</node_id>
  <title>sendPrivateMessage</title>
  <code>#sends a private message
#
#usage, examples, etc. in this node's &quot;help&quot; view:
# ?node=sendPrivateMessage&amp;type=htmlcode&amp;displaytype=help
#
#updated: (yes. Check out the [patch manager] for this kind of info)
#
#
#yes, this is *still still* in beta
#once this is stable, we'd probably get a 10000% speedup by putting this in a .pm (htmlcodes get compiled each time they're run, ouch) (or did JB integrate the compile-o-cache thing from a newer ecore?)
#

#testtesttest: 1 user, not me. /msg to it says 1 user *and* 1 UG got. CC /msg says 1 user and 1 UG got. Should say 2 users. Or are we ignoring me?

#TODO error condition for certain alias (me, I, anything else?) (maybe just hardcode in here, if a few)
#TODO if target is bot (use bot setting), see if they have a special htmlcode (probably best to run after did everything else)

#big big big big TODO: put this info into help displaytype ALSO 
#massive like OMG semi-trailer-truck-sized TODO: recode website; take tea when done
#big TODO:
#	How do we want to handle don't-send-to-self and auto-archive-when-sending-to-self ?
#	I've had 2 false starts that are specific to single-target, pseudo-group, and usergroup, but are pretty clumsy
#	I'm now thinking maybe doing something like msg-ignore: user can specify groups to do certain things to.
#
#thought #2: instead of making another table, since this is all user-based, we can just throw things into VARS
#	maybe: 'automsgsend_###' where ### is node_id of recipient (group or usergroup)
#	if multiple cases match, do one that keeps the most
#	bits:
#		0    1      if NOT set, ignore everything else, and use default settings
#		1-2  2,4,6  0=default, 2=always CC self, 4=never get self, 6=reserved
#		4    8      set archived flag, if happens to get message

#another thought: maybe change 'archive' field into 'folder' field; needs more thought: who create? who view? etc.


#
#parameters setup, part 1 of 2
#

my $params = shift;
my $showWhatSaid = $params-&gt;{show_said};

#
#constants and global vars setup, part 1 of 2
#

my $UID = $USER-&gt;{node_id} || 0;

return '' if $APP-&gt;isGuest($USER);
return '' if $USER-&gt;{title} eq 'everyone';
return 'Nothing to send: no message was given.' unless $params-&gt;{message};
my $msg = $APP-&gt;messageCleanWhitespace($params-&gt;{message});
return 'Nothing to send: message only consists of &quot;whitespace&quot; characters (for example, a space).' unless length($msg);


my $cachedTitles = undef;
my $cachedIDs = undef;

#failure warning messages
#these are always sent to the current user (which is not neccessarily the author we say the message is from)
my @problems = ();
#
#subroutines
#

#returns if a parameter is set to 1 or not
#if the given parameter exists and equals '1', then true is returned
#any other condition will return false
local *boolParam = sub {
	return (defined $_[0]) &amp;&amp; (exists $params-&gt;{$_[0]}) &amp;&amp; (defined $params-&gt;{$_[0]}) &amp;&amp; ($params-&gt;{$_[0]} eq '1');
};

#gets a user or usergroup
#pass ($title) to get based on title (respecting chatterbox forwards)
#pass ($id, 1) to get based on node ID
#passed username should NOT be escaped
##this tries really hard to deal with names with spaces and/or underscores, and should get them, no matter how they are set up
#note: do NOT optimize this to use the light-get, since then usergroups wouldn't have their group members loaded (this may be no longer true - does the UG auto code deal with this properly?)
#updated: 2002.11.10.n0
my $FORWARDS;
local *getCached = sub {
	my ($ident,$isNumeric) = (@_[0,1]);
	return undef unless defined($ident) &amp;&amp; length($ident);
	my $N = undef;

	#get by ID
	if((defined $isNumeric) &amp;&amp; $isNumeric) {
		return undef unless $ident =~ /^(\d+)$/;
		$ident=$1;
		return $cachedIDs-&gt;{$ident} if exists $cachedIDs-&gt;{$ident};
		$N=getNodeById($ident);
		if(!$APP-&gt;isUserOrUsergroup($N)) { undef $N; }
		if((defined $N) &amp;&amp; (exists $N-&gt;{title}) &amp;&amp; length($N-&gt;{title})) {
			$cachedTitles-&gt;{$N-&gt;{title}} = $N;
		}
		$cachedIDs-&gt;{$ident} = $N;

	#get by title
	} else {
		return $cachedTitles-&gt;{$ident} if exists $cachedTitles-&gt;{$ident};

		#given title isn't cached, so find it
		#a forward address takes precedence over a real user
		if(!defined $FORWARDS) {
			$FORWARDS = getVars(getNode('chatterbox forward','setting'));
		}
		my $forwarded = (exists $FORWARDS-&gt;{lc $ident}) ? $FORWARDS-&gt;{lc $ident} : $ident;
		my $escaped = $DB-&gt;quote($forwarded);

		$N = getNode($forwarded,&quot;usergroup&quot;) || getNode($forwarded,&quot;user&quot;) || undef;
		if(!defined $N) {
			#try getting, underscores converted to spaces
			$forwarded =~ tr/_/ /;
			$N = getNode($forwarded,&quot;usergroup&quot;) || getNode($forwarded,&quot;user&quot;) || undef;
		}

		#on 2002.11.09.n5, removed space-and-underscore-in-name code; see displaytype=help for more information

		#found (or didn't find), so cache title and possibly forward
		#note: $N may be invalid, but we're still caching the miss-hit, so we don't try getting it again
		$cachedIDs-&gt;{$N-&gt;{node_id}} = $N if defined $N;
		$cachedTitles-&gt;{$ident} = $N;
		$cachedTitles-&gt;{$forwarded} = $N unless $ident eq $forwarded;
	}

	return $N;
};

#returns a list ref of items in a given parameter
#if a given parameter (in $param) is invalid, an empty list ref is returned
#otherwise, a list ref of all items is returned
local *getParamList = sub {
	my $p=$_[0];
	my @l = ();
	if( (defined $p) &amp;&amp; (exists $params-&gt;{$p}) &amp;&amp; (defined $params-&gt;{$p}) ) {
		$p=$params-&gt;{$p};
		my $r=ref $p;
		if($r eq '') {
			@l = ($p);
		} elsif($r eq 'SCALAR') {
			@l = ($$p);
		} elsif($r eq 'ARRAY') {
			return $p;
		} elsif($r eq 'HASH') {
			@l = keys(%$p);
		}
	}
	return \@l;
};


#
# main function
#

#determine author
#note: in most cases, we'll just skip to the last 'unless' to use current user
my $aid = $params-&gt;{author_id};
if((defined $aid) &amp;&amp; length($aid) &amp;&amp; $aid &amp;&amp; ($aid =~ /^(\d+)$/)) {
	$aid = getNodeById($1,'light') || undef;	#note that this allows any node to /msg user
	$aid = (defined $aid) ? $aid-&gt;{node_id} : undef;
} else {
	undef $aid;
}
unless(defined $aid) {
	#don't know author ID, so try to get author name
	$aid = $params-&gt;{author};
	if((defined $aid) &amp;&amp; length($aid)) {
		$aid = getCached($aid) || undef;
		$aid = (defined $aid) ? $aid-&gt;{node_id} : undef;
	}
}
unless(defined $aid) {
	#don't know author's title, either, so just use current user
	$aid = $UID;
}


#determine node message is about
#note: if message table is expanded to include something like 'about_node', this section can be mostly removed
my $aboutNode = $params-&gt;{renode_id};
if((defined $aboutNode) &amp;&amp; length($aboutNode) &amp;&amp; $aboutNode &amp;&amp; ($aboutNode=~/^(\d+)$/)) {
	$aboutNode = getNodeById($1,'light') || undef;
	if(defined $aboutNode) {
		$aboutNode = length($aboutNode-&gt;{title}) ? $aboutNode-&gt;{title} : 'id://'.$aboutNode-&gt;{node_id};
	}
} else {
	undef $aboutNode;
}
unless(defined $aboutNode) {
	$aboutNode=$params-&gt;{renode};
	if((defined $aboutNode) &amp;&amp; length($aboutNode) &amp;&amp; ($aboutNode=~/^(.+)$/)) {
		$aboutNode=length($1) ? $1 : undef;
	} else {
		undef $aboutNode;
	}
}

#determine time to say message was sent
my $sendTime = $params-&gt;{renode_id};
if((defined $sendTime) &amp;&amp; ($sendTime =~ /^(\d{14,})$/)) {	#Y10K compliant
	$sendTime = $1;
} else {
	undef $sendTime;
}

#determine which usergroup to say message was from
my $fromGroup = $params-&gt;{fromgroup_id};
if( (defined $fromGroup) &amp;&amp; length($fromGroup) &amp;&amp; $fromGroup &amp;&amp; ($fromGroup=~/^(\d+)$/) ) {
	$fromGroup = getNodeById($1,'light') || undef;
	if(defined $fromGroup) {
		$fromGroup = $fromGroup-&gt;{node_id};
	}
} else {
	$fromGroup = 0;
}
unless($fromGroup) {
	if((defined $fromGroup) &amp;&amp; length($fromGroup) &amp;&amp; ($fromGroup=~/^(.+)$/)) {
		if(length($1)) {
			$fromGroup=getCached($1);
			$fromGroup = (defined $fromGroup) ? $fromGroup-&gt;{node_id} : 0;
		} else {
			$fromGroup=0;
		}
	} else {
		$fromGroup=0;
	}
}

#
#determine recipient(s)
#

#determine who is online
my %onlines = ();
my $onlineOnly = boolParam('ono');
if($onlineOnly) {
	#ripped from message (opcode)
	my $csr = $DB-&gt;sqlSelectMany('member_user', 'room', '', '');
	while(my ($ol) = $csr-&gt;fetchrow) {
		$onlines{$ol}=1;
	}
	$csr-&gt;finish;
}

#determine which groups get a copy sent to themselves
my $ccGroups = boolParam('ccgroup');

my $countUserAll = 0;	#count of users we tried to /msg, including those ignoring us
my $countUserGot = 0;	#count of users that got our message
my $countGroupGot = 0;	#count of groups that got our message
#users who blocked us; key is user ID, value is 0 if blocked, 1 if possibly blocked (happens ignoring the usergroup, but could still get msg via another usergroup)
#	after trying to send to everybody, anything with value of 1 is added to $countUserAll
my %blockers = ();

my %groups = ();	#groups that get a message; key is group ID, value is -1 if user isn't allowed to send there, 0 if usergroup doesn't get message (but people in it do), higher than 0 means the usergroup also gets the message
my %users = ();	#users that get a message; key is user ID, value is group they're in (or 0 for none) (or -1 to not send to them)
#%users is a hash so if multiple usergroups are messaged, the user will get a group message for a group they're in, instead of potentially a group they aren't in


#
#general routines that hopefully will be later moved to npbutil
#


#returns a value in $VARS-&gt;{_argument_}, constrained to the given values
#parameters are all required:
#	value to get value of in VARS
#	default value to return, if value is not in VARS hash, or value is not one of the given values
#	list or list ref of valid values
#returns if all arguments aren't supplied
#created: 2002.06.15.n6
#updated: 2002.06.15.n6
#TODO move into npbutil, after it is cleaned a bit
#TODO bool version also for npbutil
local *getVarsValue = sub {
	my ($varsKey, $defaultVal, @allowedValues) = @_;

	return unless (defined $varsKey) &amp;&amp; length($varsKey);

	#possibly change list ref into list
	if( (scalar(@allowedValues)==1) &amp;&amp; ((ref $allowedValues[0]) eq 'ARRAY') ) {
		@allowedValues = @{$allowedValues[0]};
	}

	#determine what to return
	return $defaultVal unless exists $VARS-&gt;{$varsKey};
	my $val = $VARS-&gt;{$varsKey};
	foreach(@allowedValues) {
		return $val if $_ eq $val;
	}
	return $defaultVal;

};


#
# flag recipients
#


#adds a user to the list to get the message (or not get message)
#pass user object and optionally group ID (if no group is passed, defaults to no group)
#included in things this functions does:
#	all checks for where a user would not get a message: online-only, ignoring user, ignoring group
#	finding (and possibly increasing) the msg group level
#updated: 2002.11.09.n6
local *addUser = sub {
	my ($userObj, $groupID) = @_[0,1];
	return unless defined $userObj;
	$groupID = (defined $groupID) ? $groupID : 0;
	my $uid = $userObj-&gt;{node_id};

	if(exists $users{$uid}) {
		#user is already getting message

		return if $users{$uid}==-1;	#user doesn't want message

		#if this is a group message, see if user knows it is from a group
		if($groupID &amp;&amp; ($users{$uid}==0)) {
			#user doesn't know this is from a group, so say it is
			$users{$uid}=$groupID;
		}
    # note: should always be true, but just in case
	} else {
		#user isn't set to get/not get a message

		#check for ignoring author
		if( $APP-&gt;userIgnoresMessagesFrom($uid, $aid) ) {
			$users{$uid}=-1;
			$blockers{$uid}=0;
			++$countUserAll;
			return;
		}

		#check for online only
		#this check should be before ignore-usergroup test; otherwise, the blocked-user message incorrectly includes people who are just ignoring OnO messages
		if($onlineOnly &amp;&amp; !exists $onlines{$uid}) {
			#message is online-only and the recipient isn't online
			#see if they want the message anyway
			#TODO? cache this?
			my $v = getVars($userObj);
			unless( $v-&gt;{getofflinemsgs} ) {
				#user doesn't want ONO messages, and this msg was ONO, so block them from getting the message (to prevent having to look up their VARS again)
				$users{$uid}=-1;
				return;
			}
		}

		#check for ignoring usergroup
		#	The proper thing to do isn't clear when the recipient user is in
		#	several of the usergroups this message is going to, and the
		#	recipient is ignoring some groups, but not others. We could either
		#	block the message if ANY of the usergroups are ignored, or block if
		#	ALL of the usergroups are ignored. The latter case is done here;
		#	this means there is a lower chance you'll miss a message you meant
		#	to get, although there is a higher chance you'll get a message you
		#	did not want.
		if($groupID) {
			$blockers{$uid}=$groupID;	#non-zero means may still get message
			#don't mark as send-message, but also don't mark as do-not-send-at-all
			return if( $APP-&gt;userIgnoresMessagesFrom($uid, $groupID) );
			#note: countUsersAll is not adjusted here, so it doesn't count the same recipient twice; it is added later (&quot;deal with people who blocked&quot;)
		}

		#passed all checks, so allow message to be sent to user
		delete $blockers{$uid};	#if blocked from 1 usergroup, but got anyway, forget that we tried to block
		++$countUserAll;
		++$countUserGot;
		$users{$uid}=$groupID;
	}
};

#adds a user or usergroup to get a message (or not get the message)
#pass user or usergroup object
#updated: 2004.12.12.n0 (Sunday, December 12, 2004)
local *addRecipient = sub {
	my $u = $_[0];
	return unless defined $u;
	my $i=$u-&gt;{node_id};

	if( $APP-&gt;isUsergroup($u) ) {

		if(exists $groups{$i}) {
			#already did this group, don't bother with again
			next;
		}
         
		unless($APP-&gt;inUsergroup($USER, $u) ) { 
			push @problems, 'You are not allowed to message the ['.$u-&gt;{title}.'] usergroup.';
			$groups{$i}=-1;
			return;
		}

		#all checks pass, so send /msg to group and members
		++$countGroupGot;

		#see if usergroup itself gets a copy
		if($ccGroups) {
			#htmlcode caller forced groups to get
			$groups{$i} = $i;
		} else {
                        
			$groups{$i} = ($APP-&gt;getParameter($i, 'allow_message_archive') ) ? $i : 0;	#see if group gets a copy
		}

		#loop though all users
		foreach( @{$DB-&gt;selectNodegroupFlat($u)} ) {
			addUser($_, $i);
		}

	} else {
		addUser($u);

	}
};



#invalid node titles, aliases, and node IDs
#	key is invalid item
#	value is always 1
my %invalidIDs = ();
my %invalidNames = ();

#for each recipient, either:
#	add to send list
#	reject for some reason (examples: permission denied, online-only)
#	add to invalid item list

#this is the only place where recipients are added to the list to be messaged
my $n = undef;
foreach( @{getParamList('recipient_id')} ) {
	$n = getCached($_,1);
	if(defined $n) {
		addRecipient($n);
	} else {
		$invalidIDs{$_}=1;
	}
}
foreach( @{getParamList('recipient')} ) {
	$n = getCached($_);
	if(defined $n) {
		addRecipient($n);
	} else {
		$n = $_;
		$n =~ tr/ /_/;
		$invalidNames{$n}=1;
	}
}

#deal with people who blocked
my @whoBlocked = ();	#users who blocked sender, and not because blocking the group (listing all the group blockers could get large fast)
my $numBlocked = scalar(keys(%blockers));
my $numBlockedGroup = 0;	#number of messages blocked because blocking usergroup
foreach(keys(%blockers)) {
	if($blockers{$_}==0) {
		#blocking sender
		push(@whoBlocked, getCached($_,1));
	} else {
		#blocking usergroup(s)
		++$countUserAll;	#not done in addUser, so do it now
		++$numBlockedGroup;
	}
}
my $blockedInfoMethod = getVarsValue('informmsgignore', 0, 0,1,2,3);	#0=inform via msg, 1=inform in 'you said &quot;blah&quot;' area in chatterbox, 2=inform both ways, 3=don't inform

if($numBlocked &amp;&amp; ($blockedInfoMethod==0 || $blockedInfoMethod==2)) {
	#inform via a msg
	my $bMessage = 'You were blocked by '.$numBlocked.' user'.($numBlocked==1?'':'s').' total';
	my @bReason = ();
	push(@bReason, $numBlockedGroup.' ignored the usergroup(s)') if $numBlockedGroup;
	push(@bReason, scalar(@whoBlocked).' ('.join(', ', map { '[' . $_-&gt;{title} . ']' } @whoBlocked).') ignored you') if scalar(@whoBlocked);
	$bMessage .= ': '.join(', ', @bReason) if scalar(@bReason);	#note: should always be true, but just in case
	$bMessage .= '.';
	push(@problems, $bMessage);
}

#when sending a message and we aren't a recipient, but we get it anyway, pick one of the normal recipients to be the for_usergroup
#	if the message was sent to any usergroups, pick one of those
#	otherwise, pick a random user
#	in either case, this will return the node_id of the choosen node for for_usergroup
#created: 2002.07.28.n0
#updated: 2002.12.02.n1
local *pickRandomForGroup = sub {

	#first try a random group
	foreach(keys(%groups)) {
		if($_ &gt;= 0) { return $_; }	#if -1, then that group didn't get the message
	}

	#not sending to any groups, so pick a random user besides the sending user
	foreach(keys(%users)) {
		return $_ unless $_==$UID;	#yourself as a group is rather annoying
	}

	#return (exists $users{$UID}) ? $UID : 0;	#may have to return self as usergroup after all (oops, this makes all /msgs to self have yourself as a group; yuck)
	#return 0;
    #return 1;
    #return &quot;false&quot;;
    #return &quot;0&quot;;
    #return &quot;file not found&quot;;
    return 0; # note: should always be true, but just in case
    #return 0;
    #return;
};


#special case sender getting msg
if(boolParam('ccself')) {
	#set the for-group as just a random recipient of the message
	#this is far from perfect, but there isn't a way to store all recipients, so this will have to do
	#done here, and not relied upon at the actual msg-send part so we try to not get ourselves as the for-group we're sending to

	#if sending to at least 1 group, try to make that the from group

	#since we aren't sending to any groups, pick a random person
	unless(exists $users{$UID}) {
		$users{$UID} = pickRandomForGroup() || $UID;	#extra OR is for very rare case so user still gets CC-to-self message when nobody gets message (such as everybody is blocking sender)
	}
}

#add things to message
if($onlineOnly) {
	#say ONO even for CCed to self message as a reminder of how it was sent
	$msg = 'OnO: ' . $msg;
}
if(defined $aboutNode) {
	#maybe FIXME: add another field to message table, although this wouldn't be used much (just for WU title area)
	$msg = 're ['.$aboutNode.']: '.$msg;
}

#construct invalid recipients message
my $s = '';
my @badIDs = sort { ($a&lt;=&gt;$b) || ($a cmp $b) } keys(%invalidIDs);
if($n=scalar(@badIDs)) {
	$s = 'Node ID' . ($n==1
		? ' ' . $badIDs[0] . ' is not a valid user or usergroup ID.'
		: 's ' . join(', ', @badIDs) . ' are not valid user or usergroup IDs.'
	);
}
my @badNames = sort { $a cmp $b } keys(%invalidNames);
if($n=scalar(@badNames)) {
	$s .= ' ' if length($s);
	if($n==1) {
		$s .= encodeHTML($badNames[0]) . ' is not a valid user or usergroup name or alias.';
	} else {
		$s .= encodeHTML(join(@badNames)) . ' are not valid user or usergroup names or aliases.';
	}
}
if(length($s)) {
	push(@problems, $s . ' You tried to say: \\n ' . encodeHTML($msg));	#slash, then 'n', not newline
}


#
# finally send the message
#

my $i = undef;
my @getters = ();	#groups and users that got message

#send to groups archive
foreach $i (keys(%groups)) {
	 next if $groups{$i}&lt;0;	#negative indicates user isn't allowed to send to group
	 push(@getters, $i);	#count as 1 for group
	 next if $groups{$i}==0;

	 $DB-&gt;sqlInsert('message',{
		    'msgtext' =&gt; $msg,
		    'author_user' =&gt; $aid,
		    'tstamp' =&gt; $sendTime,
		    'for_user' =&gt; $i,
		    'for_usergroup' =&gt; $i,	#don't bother with ($i || $fromGroup) since $i is never going to be 0
	});
}

#send to users
my $forUG = undef;
my $isArchived = undef;
foreach $i (keys(%users)) {

	next if $users{$i}&lt;0;

	$forUG=$users{$i};
	if($i==$UID) {
		#the for-group is really just a random recipient of the message
		#this is far from perfect, but there isn't a way to store all recipients, so this will have to do
		#if the msg was forced-gotten, then this was already done; but this is for the normal case
		$forUG ||= pickRandomForGroup();
	}
	$isArchived=0;
	$forUG ||= $fromGroup;

	push(@getters, $i) if $users{$i}==0;	#only list people that aren't in a UG (otherwise, UG recipient list would be quite large)

	$DB-&gt;sqlInsert('message',{
		'msgtext' =&gt; $msg,
		'author_user' =&gt; $aid,
		'tstamp' =&gt; $sendTime,
		'for_user' =&gt; $i,
		'for_usergroup' =&gt; $forUG,
		'archive' =&gt; $isArchived,
	});
	#message_id is auto
	#room is 0
	#fullmessage_id was never implemented (thank christ)

}

#inform user of any problems
#	since these are sent back to the sending user, increase the maximum message length
if(scalar(@problems)) {
	my $rootUser = getNode('root','user','light') || undef;
	$rootUser = (defined $rootUser) ? ($rootUser-&gt;{node_id} || 0) : 0;
	foreach my $prob (@problems) {
		$DB-&gt;sqlInsert('message',{
			'msgtext' =&gt; $prob,
			'author_user' =&gt; $rootUser,
			'for_user' =&gt; $UID,	#the actual user gets the error(s), not the author we say is sending the message
		});
	}
}


#link to groups and users that were messaged
#parameters: node_id of user, optional alternate text to display
local *linkU = sub {
	my $id = $_[0];
	my $altDisp = $_[1] || undef;
	return '&lt;em title=&quot;sendPrivateMessage (htmlcode)&quot;&gt;!!! nobody !!!&lt;/em&gt;' unless $id;
	return linkNode($id, ((defined $altDisp) ? $altDisp : getCached($id,1)-&gt;{title}));
};


#
#sent /msg information
#

#if multiple messages sent at same time (such as through the WU header area), find the query param to use
my $qpm = 'sentmessage';
if( defined $query-&gt;param($qpm) ) {
	my $i=0;
	while(defined $query-&gt;param($qpm.$i) ) {
		++$i;
	}
	$qpm=$qpm.$i;
}

#UIDs for Virgil, CME, Klaproth, and root.
my @botlist = qw(1080927 839239 952215 113);
my %bots = map{$_ =&gt; 1} @botlist;

#escape for sender's display
#Bots, don't escape HTML for them.
unless( exists $bots{$aid} ){
  $msg = escapeAngleBrackets($msg);
  $msg = parseLinks($msg,0,1);
}

my $m = undef;
if ( $aid==$UID) {
  $m = 'you said &quot;' . $msg . '&quot;';
  unless(scalar(@getters)) {
    $m .= ' to nobody';
  }
  else {
    #TODO allow only certain recipients to not be shown

    #TODO loop though list anonrecipient, create hash, foreach loop
    #     checks hash to see if that recipient is anonymous

    #TODO recode entire engine
    my $anonRecipient = boolParam('anonrecipient');
    foreach (@getters) {
      $_ = ($anonRecipient) ? linkU($_,'?') : linkU($_);
    }
    $m .= ' to ' . join(', ', @getters);
  }
  $m .= ' (sent ';
  $m .= ' to '.$countUserGot.' noder'.($countUserGot==1?'':'s');
  $m .= ' and '.$countGroupGot
    .' group'.($countGroupGot==1?'':'s') unless $countGroupGot==0;

  if ($numBlocked) {    #note: should always be true, but just in case

    $m .= ' (You were blocked by '
          .$numBlocked.' user'.($numBlocked==1?'':'s').' total';

    if ( $blockedInfoMethod==1 || $blockedInfoMethod==2 ) {

      #inform who blocked
      my @bReason = ();

      push(@bReason,
           $numBlockedGroup.' ignored the usergroup(s)') if $numBlockedGroup;

      if (scalar(@whoBlocked) ) {
        push(@bReason,
             scalar(@whoBlocked).' ('
             .join(', ', 
                   map { linkU($_-&gt;{node_id}
                               , $_-&gt;{title}) 
                       } @whoBlocked)
             .') ignored you') ;
      }

      #note: should always be true, but we haven't actually thought it
      #through
      $m .= ': '.join(', ', @bReason) if scalar(@bReason);

    }

    $m .= '.)';
  }
  $m .= ')';                    # Dear sweet christ

}
else {
  $m = &quot;You triggered a message from &quot;
       .linkNode($aid)
       .&quot; that reads \&quot;$msg\&quot;&quot;;
}

$query-&gt;param($qpm,$m);	#inform in chatterbox

return $showWhatSaid ? $m : undef;</code>
</node>
