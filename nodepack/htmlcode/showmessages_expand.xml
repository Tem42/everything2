<node>
  <type_nodetype>4</type_nodetype>
  <node_id>2015407</node_id>
  <title>showmessages_expand</title>
  <code>#originally in [chatterbox] (nodelet)
return if $APP-&gt;isGuest($USER);

my ($maxmsgs, $showOpts) = @_;

my $isEDev = exists $HTMLVARS{group_edev}{$$USER{user_id}};

#display options
$showOpts ||= '';
my $noreplylink = {$HTMLVARS{klaproth} =&gt; 1};

my $showD = $$VARS{pmsgDate} || (index($showOpts,'d')!=-1); #show date
my $showT = $$VARS{pmsgTime} || (index($showOpts,'t')!=-1); #show time
my $showDT = $showD || $showT;
my $showArc = index($showOpts,'a')!=-1;      #show archived messages (usually don't)
my $showNotArc = index($showOpts,'A')==-1;   #show non-archive messages (usually do)
return unless $showArc || $showNotArc;
my $showGroup = index($showOpts,'g')==-1;    #show group messages (usually do)
my $showNotGroup = index($showOpts,'G')==-1; #show group messages (usually do)
return unless $showGroup || $showNotGroup;
my $showDeleteBox = index($showOpts,'D') == -1;

my $showNewest = !($$VARS{chatterbox_msgs_ascend} || 0);
if ($maxmsgs =~ /^([-+])(\d+)$/) {

  $maxmsgs = $2;

  if($1 eq '-') {
    $showNewest = 1;
  } elsif($1 eq '+') {
    $showNewest = 0;
  }

} else {

  $maxmsgs = int $maxmsgs;
  $maxmsgs = undef if $maxmsgs &lt; 0;

}

$maxmsgs ||= 10;


######################################################
# sub getMessageList
# ------------------
# args:
#  $maxmsgs: int of maximum messages to retrieve,
#            undef for default
#  $getNewest: boolean -- true to get newest messages
#              blank of false to get oldest messages
#              Messages are ordered oldest first in
#              both cases
# -----
# Returns an int of total messages followed by an array
#  of private messages hashrefs for the current user
######################################################
my $getMessageList = sub {

  my ($maxmsgs, $getNewest) = @_;

  my $order = $getNewest ? 'DESC' : 'ASC';
  my $limits = 'for_user='.getId($USER);
  my $totalMsg = $DB-&gt;sqlSelect('COUNT(*)','message',$limits); #total messages for user, archived and not, group and not, from all users
  my $filterUser = $query-&gt;param('fromuser');
  if($filterUser) {
    $filterUser = getNode($filterUser, 'user');
    $filterUser = $filterUser ? $$filterUser{node_id} : 0;
  }
  $limits .= ' AND author_user='.$filterUser if $filterUser;

  my $filterMinor = ''; #things to only filter for display, and not for the &quot;X more in inbox&quot; message
  unless($showGroup &amp;&amp; $showNotGroup) {

    $filterMinor .= ' AND for_usergroup=0' unless $showGroup;
    $filterMinor .= ' AND for_usergroup!=0' unless $showNotGroup;
  }
  unless($showArc &amp;&amp; $showNotArc) {
    $filterMinor .= ' AND archive=0' unless $showArc;
    $filterMinor .= ' AND archive!=0' unless $showNotArc;
  }

  my $csr = $DB-&gt;sqlSelectMany('*', 'message', $limits . $filterMinor, &quot;ORDER BY  message_id $order LIMIT $maxmsgs&quot;);

  my @msgs;
  while(my $MSG = $csr-&gt;fetchrow_hashref) {
    push @msgs, $MSG;
  }
  $csr-&gt;finish;
  @msgs = reverse @msgs if $getNewest;
  return ($totalMsg, @msgs);
};

######################################################
# sub eddiereply
# --------------
# Takes the text of a message sent by Cool Man Eddie
#
# Returns the name of the person who cooled a writeup
#  so the reply link can go to the right place
######################################################
my $eddiereply = sub {
  my $text = shift;
  my $splitStr1='Hey, ';
  my $splitStr2=' just cooled';
  my $splitStr3=' just \[E2 Gift'; # Cater for C! gifts notifications - BlackPawn
  my @tempsplit = split($splitStr1,$text);
  my $coolStr = $tempsplit[1];

  my @coolsplit= split(/$splitStr2/,$tempsplit[1]);
  if ($coolsplit[0] eq $coolStr) {
  @coolsplit= split(/$splitStr3/,$tempsplit[1]);
  }

  my $eddie = $coolsplit[0];
  $eddie =~ s/\[//g;
  $eddie =~ s/ /_/g;
  $eddie =~ s/\]//g;
  return $eddie;
};

######################################################
# sub getFlags
# --------------
# Takes the user ID of a message
#
# Returns a string of sigils to print next to that
#  user's name
######################################################
my $getFlags = sub {
  my $flagid = shift;
  # Separating mere coders from the gods...
  my $isCommitter = htmlcode('isinUsergroup', $flagid, &quot;%%&quot;);
  my $isChanop = htmlcode('isinUsergroup', $flagid, &quot;chanops&quot;, 1);
  my $flags = '';

  if(exists $HTMLVARS{group_gods}{$flagid} &amp;&amp; !$APP-&gt;getParameter($flagid,&quot;hide_chatterbox_staff_symbol&quot;)) {
    $flags .= '@';
  } elsif($APP-&gt;isEditor($USER, &quot;nogods&quot;) &amp;&amp; !$APP-&gt;getParameter($flagid,&quot;hide_chatterbox_staff_symbol&quot;)) {
    $flags .= '$';
  }

  $flags .= '*' if $isCommitter;
  $flags .= '+' if $isChanop;
  $flags .= '%' if $isEDev &amp;&amp; exists $HTMLVARS{group_edev}{$flagid};
  if(length($flags)) {
    $flags = '&lt;small&gt;'.$flags.'&lt;/small&gt; ';
  }
  return $flags;
};

######################################################
# sub replyLink
# --------------
# args:
#   $targetId:   node_id of usergroup/user to reply to
#   $text:       text of the message being replied to
#   $anchor:     text to attach the link to
#   $onlineOnly: boolean value to pass to replyToCB()
#
# Returns a string with a reply link
######################################################
my $makeReplyLink = sub {

  my ($targetId, $text, $anchor, $onlineOnly) = @_;
  my $target = getNodeById($targetId);

  # Don't provide a reply link to a deleted target
  return '' if !$target;
  # Don't provide a reply link to yourself
  return '' if $$USER{user_id} == $targetId;

  my $targetTitle = $$target{title};
  $targetTitle =~ tr/ /_/;

  $targetTitle = &amp;$eddiereply($text) if $targetTitle eq &quot;Cool_Man_Eddie&quot;;

  # Clean up name so it can't bork the Javascript
  $targetTitle = encodeHTML($targetTitle);
  $targetTitle =~ tr/ /_/;
  $targetTitle =~ s/\\/\\\\/g;
  $targetTitle =~ s/'/\\'/g;
  
  my $linkText = '(&lt;a href=&quot;javascript:replyToCB('
    . &quot;'$targetTitle', $onlineOnly&quot; . ')&quot;'
    . ' title=&quot;Reply to ' . $targetTitle . '&quot;&gt;' . $anchor . '&lt;/a&gt;)'
    ;

  return $linkText;
};

######################################################
# sub deleteBox
# --------------
# args:
#   $messageId:  message id for delete box name
#
# Returns a string with the delete box HTML
######################################################
my $deleteBox = sub {
  my $messageId = shift;
  return &quot;&lt;span class=\&quot;deleteBox\&quot; &quot;
    . &quot; title=\&quot;Check this box and hit Talk to delete this message\&quot;&gt;&quot;
    . $query-&gt;checkbox(
        -name =&gt; &quot;deletemsg_$messageId&quot;
        , -checked =&gt; 0
        , -value =&gt; 'yup'
        , -label =&gt; ''
    )
    . &quot;&lt;/span&gt;&quot;
    ;
};

######################################################
# Main body
######################################################

#UIDs for Virgil, CME, Klaproth, and root.
my @botlist = qw(1080927 839239 952215 113);
my %bots = map{$_ =&gt; 1} @botlist;

my $str = '';
my ($totalMsg, @msgs) = &amp;$getMessageList($maxmsgs, $showNewest);

foreach my $MSG (@msgs) {
  my $text = $$MSG{msgtext};
  my $ugID = $$MSG{for_usergroup};
  my $UG = getNodeById($ugID);
  my $aid = $$MSG{author_user};  #message's author's ID
  my $a = getNodeById($aid); #message's author; have to do this in case sender has been deleted (!)
  my $userLink;

  $str .= &quot;&lt;span class=\&quot;privmsg\&quot;&gt;&quot;;
  $str .= &amp;$deleteBox($$MSG{message_id}) if $showDeleteBox;

  if($$VARS{showmessages_replylink} and not $$noreplylink{$$MSG{author_user}}){
    # Test for ONO. This is moderately cheesy because the message text 
    # could start with &quot;ONO: &quot;, but that's rare in practice. The table 
    # doesn't track ONOness, so the text is all we've got.
    my $ono = ( $text =~ /^O[nN]O: / ) || 0;

    $str .= &amp;$makeReplyLink($aid, $text, 'r', 0);
    $str .= &amp;$makeReplyLink($ugID , $text, 'ra', $ono);
  }

  $str.=' ';

  if($showDT) {
    my $tsflags = 128; # compact timestamp
    $str .= '&lt;small style=&quot;font-family: sans-serif;&quot;&gt;';
    $tsflags |= 1 if !$showT; # hide time 
    $tsflags |= 2 if !$showD; # hide date
    $str .= htmlcode('parsetimestamp', $$MSG{tstamp}, $tsflags);
    $str .= '&lt;/small&gt; ';
  }

  $str .= '(' . linkNode($UG,0,{lastnode_id=&gt;0}) . ') ' if $ugID;

  #Bots, don't escape HTML for them.
  unless( exists $bots{$$MSG{author_user}} ){
    $text = escapeAngleBrackets($text);
  }

  #N-Wing probably doing too much work...
  #changes literal '\n' into HTML breaks (slash, then n; not a newline)
  $text =~ s/\s+\\n\s+/&lt;br \/&gt;/g;

  $text =~ s/\[([^\]]*?)$/&amp;#91;$1/g; #unclosed [ fixer

  $str .= '&lt;small&gt;('.htmlcode('timesince', $a-&gt;{lasttime}, 1).')&lt;/small&gt; ' if $$VARS{chatterbox_authorsince};
  $str .= &amp;$getFlags($aid) if($$VARS{powersMsg});

  $userLink = $a ? linkNode($a,0,{lastnode_id=&gt;0}) : '?';

  $str.='&lt;cite&gt;'.$userLink.' says&lt;/cite&gt; '.parseLinks($text,0,1);
  $str.=&quot;&lt;/span&gt;&lt;br /&gt;\n&quot;;
}

my $moreMsgStr = '';

if ($totalMsg) {
  my $MI_node = getNode(&quot;Message Inbox&quot;, &quot;superdoc&quot;);
  $moreMsgStr .= linkNode($MI_node,&quot;$totalMsg private messages&quot;);
}
$str .= '&lt;br /&gt;(you have ' . $moreMsgStr . ')' if length($moreMsgStr);
$str;</code>
</node>
